<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>humane.</title>
    <link rel="icon" href="data:,">
    
    <!-- Fonts: Syne (Display), Inter (Body), VT323 (Tech/Raw) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Syne:wght@700;800&family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />

    <!-- GSAP & Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Shaders for Three.js -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4( color * vColor, 1.0 );
            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        }
    </script>

    <style>
        /* --- 2026 GEN Z / RED THEME VARS --- */
        :root {
            --c-bg: #FF3333;      /* Primary Alert Red */
            --c-ink: #050505;     /* Deep Black */
            --c-paper: #FFFFFF;   /* Stark White accents */
            
            --f-disp: 'Syne', sans-serif;
            --f-body: 'Inter', sans-serif;
            --f-mono: 'VT323', monospace;

            --border-ink: 2px solid var(--c-ink);
            --border-thin: 1px solid rgba(0,0,0,0.2);
        }

        /* --- BASE STYLES --- */
        *, *::before, *::after { box-sizing: border-box; cursor: crosshair; }

        html { scroll-behavior: smooth; }
        
        body {
            margin: 0;
            background-color: var(--c-bg);
            color: var(--c-ink);
            font-family: var(--f-body);
            overflow-x: hidden;
            /* Subtle Grain Texture */
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
        }

        h1, h2, h3, h4 { margin: 0; font-family: var(--f-disp); text-transform: uppercase; line-height: 0.9; }
        p { line-height: 1.4; font-size: 1.1rem; }
        a { color: inherit; text-decoration: none; }

        /* --- UTILS --- */
        .container { max-width: 1400px; margin: 0 auto; padding: 0 2rem; }
        .mono { font-family: var(--f-mono); letter-spacing: 0.05em; text-transform: uppercase; }
        
        /* Marquee */
        .marquee {
            background: var(--c-ink);
            color: var(--c-bg);
            padding: 0.5rem 0;
            overflow: hidden;
            white-space: nowrap;
            font-family: var(--f-mono);
            font-size: 1.2rem;
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 1000;
        }
        .marquee-inner { display: inline-block; animation: scroll 20s linear infinite; }
        @keyframes scroll { from { transform: translateX(0); } to { transform: translateX(-50%); } }

        /* --- NAVIGATION --- */
        nav {
            position: fixed;
            top: 40px;
            left: 0; right: 0;
            padding: 1.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 900;
            mix-blend-mode: normal; 
        }

        .logo { font-size: 2rem; font-weight: 800; letter-spacing: -0.05em; }
        
        .pill-badge {
            border: var(--border-ink);
            padding: 0.5rem 1.2rem;
            border-radius: 50px;
            font-family: var(--f-mono);
            font-weight: bold;
            background: transparent;
            transition: 0.3s;
        }
        .pill-badge:hover { background: var(--c-ink); color: var(--c-bg); }

        /* --- HERO --- */
        #hero {
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #magic {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-overlay {
            position: relative;
            z-index: 2;
            pointer-events: none; /* Let clicks pass to three.js */
            text-align: center;
            width: 100%;
        }

        /* --- APP INTRO / SHOWCASE --- */
        #showcase {
            padding: 8rem 0;
            background: var(--c-bg);
            border-top: var(--border-ink);
        }

        .section-header {
            font-size: clamp(3rem, 10vw, 8rem);
            margin-bottom: 4rem;
            padding: 0 2rem;
            text-align: center;
        }

        .showcase-grid {
            display: flex;
            flex-direction: column;
            gap: 6rem;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .feature-block {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            align-items: center;
            border-bottom: var(--border-ink);
            padding-bottom: 4rem;
        }
        
        @media (min-width: 900px) {
            .feature-block { grid-template-columns: 1fr 1fr; gap: 4rem; }
            .feature-block:nth-child(even) { direction: rtl; }
            .feature-block:nth-child(even) .feature-text { direction: ltr; }
        }

        .phone-mock {
            position: relative;
            width: 100%;
            max-width: 350px;
            aspect-ratio: 9/19.5;
            background: #000;
            border-radius: 40px;
            border: 3px solid #000;
            margin: 0 auto;
            overflow: hidden;
            box-shadow: 20px 20px 0px rgba(0,0,0,0.1);
            transition: transform 0.4s ease;
        }
        
        .phone-mock:hover { transform: scale(1.02) rotate(-1deg); }

        .phone-mock img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .feature-text h3 {
            font-size: clamp(2.5rem, 5vw, 4rem);
            margin-bottom: 1rem;
            color: var(--c-ink);
        }
        
        .feature-text p {
            font-family: var(--f-mono);
            font-size: 1.2rem;
            max-width: 400px;
        }

        /* --- DIAGNOSTICS (Simplified) --- */
        #diagnostics {
            background: var(--c-ink);
            color: var(--c-bg);
            padding: 6rem 2rem;
            font-family: var(--f-mono);
        }
        
        .diag-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .diag-item {
            border: 1px solid var(--c-bg);
            padding: 2rem;
        }
        .diag-item h4 { font-size: 2rem; margin-bottom: 1rem; }

        /* --- VIDEO --- */
        #video-section {
            background: var(--c-bg);
            padding: 4rem 2rem;
        }
        
        .video-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            border: var(--border-ink);
            position: relative;
            background: #000;
        }

        video {
            display: block;
            width: 100%;
            /* TINT EFFECT: Multiply blend mode acts as a red filter */
            mix-blend-mode: luminosity; 
            opacity: 0.8;
        }
        
        /* Red Overlay to colorize the grayscale video */
        .video-tint {
            position: absolute;
            inset: 0;
            background: var(--c-bg);
            mix-blend-mode: multiply;
            pointer-events: none;
        }

        /* --- FOOTER --- */
        footer {
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
            border-top: var(--border-ink);
            padding: 2rem;
        }

        .mega-text {
            font-size: clamp(4rem, 18vw, 15rem);
            font-weight: 800;
            line-height: 0.8;
            letter-spacing: -0.04em;
        }

        .download-btn {
            margin-top: 3rem;
            background: var(--c-ink);
            color: var(--c-bg);
            padding: 1.5rem 4rem;
            font-family: var(--f-mono);
            font-size: 1.5rem;
            border-radius: 999px;
            transition: transform 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 1rem;
        }
        .download-btn:hover { transform: scale(1.05); }

        /* Stickers */
        .sticker {
            position: absolute;
            background: var(--c-paper);
            color: var(--c-ink);
            padding: 0.5rem 1rem;
            font-family: var(--f-mono);
            font-weight: bold;
            border: 2px solid var(--c-ink);
            transform: rotate(-10deg);
            box-shadow: 4px 4px 0px var(--c-ink);
            pointer-events: none;
        }

    </style>
</head>
<body>

    <!-- MARQUEE -->
    <div class="marquee">
        <div class="marquee-inner">
            /// SYSTEM REWIRED /// NO ALGORITHMS /// NO LIKES /// DISCUSS WITH REAL USERS /// NO CLOUD /// GHOST MODE ACTIVE /// SYSTEM REWIRED /// NO ALGORITHMS /// NO LIKES /// DISCUSS WITH REAL USERS  ///
        </div>
    </div>

    <!-- NAV -->
    <nav>
        <a href="#" class="logo">humane.</a>
        <div style="display: flex; gap: 1rem; align-items: center;">
            <span class="mono" style="display: none; @media(min-width:600px){display:inline;}">DOPAMINE: <span id="score">0</span>%</span>
            <a href="https://github.com/red-humane/talk-to-me/releases/download/version-1.0.0/Talk-to-me.apk" class="pill-badge">GET APP</a>
        </div>
    </nav>

    <!-- HERO -->
    <section id="hero">
        <div id="magic"></div>
        
        <!-- Absolute positioned stickers for Gen Z chaotic feel -->
        <div class="sticker" style="top: 20%; left: 10%; transform: rotate(15deg);">v1.0.0_STABLE</div>
        <div class="sticker" style="bottom: 20%; right: 10%; background: var(--c-ink); color: var(--c-bg);">DISCONNECT</div>
    </section>

    <!-- APP SHOWCASE (Replaces Evolution) -->
    <section id="showcase">
        <h2 class="section-header">THE INTERFACE<br>IS <span style="text-decoration: underline;">SILENT</span>.</h2>
        
        <div class="showcase-grid">
            
            <!-- Feature 1 -->
            <div class="feature-block">
                <div class="phone-mock">
                    <img src="https://i.postimg.cc/zX7164QS/frame-1.png" alt="Gesture UI">
                </div>
                <div class="feature-text">
                    <span class="mono">01 // GESTURE_CONTROL</span>
                    <h3>MINIMAL<br>INPUT</h3>
                    <p>No buttons. No distractions. A pure black canvas designed to respect your attention span.</p>
                </div>
            </div>

            <!-- Feature 2 -->
            <div class="feature-block">
                <div class="phone-mock">
                    <img src="https://i.postimg.cc/sDmRqbLW/frame-2.png" alt="Privacy">
                </div>
                <div class="feature-text">
                    <span class="mono">02 // GHOST_PROTOCOL</span>
                    <h3>ZERO<br>TRACE</h3>
                    <p>No login required. No cloud storage. Messages self-destruct in 3 minutes. You were never here.</p>
                </div>
            </div>

            <!-- Feature 3 -->
            <div class="feature-block">
                <div class="phone-mock">
                    <img src="https://i.postimg.cc/ZKHh2XQr/frame-3.png" alt="Voice Chat">
                </div>
                <div class="feature-text">
                    <span class="mono">03 // HUMAN_CONN</span>
                    <h3>REAL<br>YOU</h3>
                    <p>Speak naturally. Be you. Reclaiming the nuance of human emotion.</p>
                </div>
            </div>

        </div>
    </section>

    <!-- DIAGNOSTICS (Minimal) -->
    <section id="diagnostics">
        <div class="container">
            <h2 style="margin-bottom: 3rem; border-bottom: 1px solid var(--c-bg); padding-bottom: 1rem;">REALITY_CHECK</h2>
            <div class="diag-grid">
                <div class="diag-item">
                    <h4>INFINITE_SCROLL</h4>
                    <p>>> STATUS: BLOCKED</p>
                    <p>>> Doomscrolling algorithms removed. End of content reached.</p>
                </div>
                <div class="diag-item">
                    <h4>METRICS</h4>
                    <p>>> STATUS: NULL</p>
                    <p>>> No like counts. No view counts. No social validation loops.</p>
                </div>
                <div class="diag-item">
                    <h4>ADS</h4>
                    <p>>> STATUS: PURGED</p>
                    <p>>> You are not the product. You are the user.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- VIDEO -->
    <section id="video-section">
        <div class="video-container">
            <video autoplay muted loop playsinline>
                <source src="https://github.com/red-humane/humane-intro/raw/refs/heads/main/Duration_8_seconds_202601212249_ev4ux.mp4" type="video/mp4">
            </video>
            <div class="video-tint"></div>
            <div style="position: absolute; top: 20px; left: 20px; color: white; font-family: var(--f-mono); z-index: 5;">
                REC ● [LIVE_FEED]
            </div>
        </div>
    </section>

    <!-- FOOTER -->
    <footer>
        <p class="mono">AVAILABLE NOW ON ANDROID</p>
        <div class="mega-text">TALK<br>TO ME.</div>
        
        <a href="https://github.com/red-humane/talk-to-me/releases/download/version-1.0.0/Talk-to-me.apk" class="download-btn">
            <span class="material-symbols-outlined">android</span>
            INSTALL APK
        </a>

        <div class="mono" style="margin-top: 4rem; opacity: 0.6; font-size: 0.9rem;">
            © 2026 HUMANE CORP // NO RIGHTS RESERVED
        </div>
    </footer>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // --- THREE.JS SETUP ---
        const preload = () => {
            let manager = new THREE.LoadingManager();
            manager.onLoad = function() { 
                const environment = new Environment( typo, particle );
            }
            var typo = null;
            const loader = new FontLoader( manager );
            const fontUrl = 'https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json';
            const particleUrl = 'https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png';
            loader.load(fontUrl, function ( font ) { typo = font; });
            const particle = new THREE.TextureLoader( manager ).load( particleUrl );
        }

        if ( document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) preload();
        else document.addEventListener("DOMContentLoaded", preload ); 

        class Environment {
            constructor( font, particle ){ 
                this.font = font;
                this.particle = particle;
                this.container = document.querySelector( '#magic' );
                this.scene = new THREE.Scene();
                this.createCamera();
                this.createRenderer();
                this.setup()
                this.bindEvents();
            }

            bindEvents(){
                window.addEventListener( 'resize', this.onWindowResize.bind( this ));
            }

            setup(){ 
                this.createParticles = new CreateParticles( this.scene, this.font, this.particle, this.camera, this.renderer );
            }

            render() {
                this.createParticles.render()
                this.renderer.render( this.scene, this.camera )
            }

            createCamera() {
                this.camera = new THREE.PerspectiveCamera( 65, this.container.clientWidth /  this.container.clientHeight, 1, 10000 );
                this.camera.position.set( 0,0, 100 );
            }

            createRenderer() {
                this.renderer = new THREE.WebGLRenderer({ alpha: true });
                this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );
                this.renderer.setPixelRatio( Math.min( window.devicePixelRatio, 2));
                this.container.appendChild( this.renderer.domElement );
                this.renderer.setAnimationLoop(() => { this.render() })
            }

            onWindowResize(){
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize( this.container.clientWidth, this.container.clientHeight );
            }
        }

        class CreateParticles {
            constructor( scene, font, particleImg, camera, renderer ) {
                this.scene = scene;
                this.font = font;
                this.particleImg = particleImg;
                this.camera = camera;
                this.renderer = renderer;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2(-200, 200);
                this.colorChange = new THREE.Color();
                this.buttom = false;
                this.data = {
                    text: 'TALK\nTO ME',
                    amount: 1000,
                    particleSize: 1,
                    particleColor: 0x000000, // CHANGED TO BLACK
                    textSize: 10,
                    area: 100,
                    ease: .05,
                }
                this.setup();
                this.bindEvents();
            }

            setup(){
                const geometry = new THREE.PlaneGeometry( 100, 100 );
                const material = new THREE.MeshBasicMaterial( { visible: false } );
                this.planeArea = new THREE.Mesh( geometry, material );
                this.scene.add(this.planeArea);
                this.createText();
            }

            bindEvents() {
                document.addEventListener( 'mousedown', this.onMouseDown.bind( this ));
                document.addEventListener( 'mousemove', this.onMouseMove.bind( this ));
                document.addEventListener( 'mouseup', this.onMouseUp.bind( this ));
                // Touch
                document.addEventListener( 'touchstart', (e) => this.onMouseDown(e.touches[0]) );
                document.addEventListener( 'touchmove', (e) => this.onMouseMove(e.touches[0]) );
                document.addEventListener( 'touchend', this.onMouseUp.bind(this) );
            }

            onMouseDown(event){
                this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                this.buttom = true;
                this.data.ease = .01;
            }

            onMouseUp(){
                this.buttom = false;
                this.data.ease = .05;
            }

            onMouseMove(event) { 
                this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }

            render( level ){ 
                const time = ((.001 * performance.now())%12)/12;
                const zigzagTime = (1 + (Math.sin( time * 2 * Math.PI )))/6;

                this.raycaster.setFromCamera( this.mouse, this.camera );
                const intersects = this.raycaster.intersectObject( this.planeArea );

                if ( intersects.length > 0 ) {
                    const pos = this.particles.geometry.attributes.position;
                    const copy = this.geometryCopy.attributes.position;
                    const coulors = this.particles.geometry.attributes.customColor;
                    const size = this.particles.geometry.attributes.size;

                    const mx = intersects[ 0 ].point.x;
                    const my = intersects[ 0 ].point.y;
                    const mz = intersects[ 0 ].point.z;

                    for ( var i = 0, l = pos.count; i < l; i++) {
                        const initX = copy.getX(i);
                        const initY = copy.getY(i);
                        const initZ = copy.getZ(i);

                        let px = pos.getX(i);
                        let py = pos.getY(i);
                        let pz = pos.getZ(i);

                        // Base Color: Black
                        this.colorChange.setHex( 0x000000 ); 
                        coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                        coulors.needsUpdate = true;

                        size.array[ i ]  = this.data.particleSize;
                        size.needsUpdate = true;

                        let dx = mx - px;
                        let dy = my - py;
                        const dz = mz - pz;

                        const mouseDistance = this.distance( mx, my, px, py )
                        let d = ( dx = mx - px ) * dx + ( dy = my - py ) * dy;
                        const f = - this.data.area/d;

                        if( this.buttom ){ 
                            const t = Math.atan2( dy, dx );
                            px -= f * Math.cos( t );
                            py -= f * Math.sin( t );

                            this.colorChange.setHex( 0xffffff ); // White on click (Inverted)
                            coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                            coulors.needsUpdate = true;
                        } else {
                            if( mouseDistance < this.data.area ){
                                if(i%5==0){
                                    const t = Math.atan2( dy, dx );
                                    px -= .03 * Math.cos( t );
                                    py -= .03 * Math.sin( t );
                                    this.colorChange.setHex( 0x330000 ); // Dark Red Hover
                                    coulors.setXYZ( i, this.colorChange.r, this.colorChange.g, this.colorChange.b )
                                    coulors.needsUpdate = true;
                                    size.array[ i ]  =  this.data.particleSize /1.2;
                                    size.needsUpdate = true;
                                } else {
                                    const t = Math.atan2( dy, dx );
                                    px += f * Math.cos( t );
                                    py += f * Math.sin( t );
                                    pos.setXYZ( i, px, py, pz );
                                    pos.needsUpdate = true;
                                    size.array[ i ]  = this.data.particleSize * 1.3 ;
                                    size.needsUpdate = true;
                                }
                            }
                        }

                        px += ( initX  - px ) * this.data.ease;
                        py += ( initY  - py ) * this.data.ease;
                        pz += ( initZ  - pz ) * this.data.ease;

                        pos.setXYZ( i, px, py, pz );
                        pos.needsUpdate = true;
                    }
                }
            }

            createText(){ 
                let thePoints = [];
                let shapes = this.font.generateShapes( this.data.text , this.data.textSize  );
                let geometry = new THREE.ShapeGeometry( shapes );
                geometry.computeBoundingBox();
                const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
                const yMid =  - 0.5 * ( geometry.boundingBox.max.y - geometry.boundingBox.min.y );
                geometry.center();

                let holeShapes = [];
                for ( let q = 0; q < shapes.length; q ++ ) {
                    let shape = shapes[ q ];
                    if ( shape.holes && shape.holes.length > 0 ) {
                        for ( let  j = 0; j < shape.holes.length; j ++ ) {
                            let  hole = shape.holes[ j ];
                            holeShapes.push( hole );
                        }
                    }
                }
                shapes.push.apply( shapes, holeShapes );

                let colors = [];
                let sizes = [];
                for ( let  x = 0; x < shapes.length; x ++ ) {
                    let shape = shapes[ x ];
                    const amountPoints = ( shape.type == 'Path') ? this.data.amount/2 : this.data.amount;
                    let points = shape.getSpacedPoints( amountPoints ) ;
                    points.forEach( ( element, z ) => {
                        const a = new THREE.Vector3( element.x, element.y, 0 );
                        thePoints.push( a );
                        colors.push( this.colorChange.r, this.colorChange.g, this.colorChange.b);
                        sizes.push( 1 )
                    });
                }

                let geoParticles = new THREE.BufferGeometry().setFromPoints( thePoints );
                geoParticles.translate( xMid, yMid, 0 );
                geoParticles.setAttribute( 'customColor', new THREE.Float32BufferAttribute( colors, 3 ) );
                geoParticles.setAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1) );

                const material = new THREE.ShaderMaterial( {
                    uniforms: {
                        color: { value: new THREE.Color( 0xffffff ) },
                        pointTexture: { value: this.particleImg }
                    },
                    vertexShader: document.getElementById( 'vertexshader' ).textContent,
                    fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                    blending: THREE.NormalBlending, // Changed from Additive to Normal for black particles
                    depthTest: false,
                    transparent: true,
                } );

                this.particles = new THREE.Points( geoParticles, material );
                this.scene.add( this.particles );
                this.geometryCopy = new THREE.BufferGeometry();
                this.geometryCopy.copy( this.particles.geometry );
            }

            distance (x1, y1, x2, y2){
                return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));
            }
        }

        // --- GSAP ANIMATIONS ---
        gsap.registerPlugin(ScrollTrigger);

        // Feature Reveal
        gsap.utils.toArray('.feature-block').forEach(block => {
            gsap.from(block, {
                scrollTrigger: { trigger: block, start: "top 80%" },
                y: 100,
                opacity: 0,
                duration: 1,
                ease: "power3.out"
            });
        });

        // Gamification Score
        let score = 0;
        const scoreEl = document.getElementById('score');
        window.addEventListener('scroll', () => {
            if(Math.random() > 0.8 && scoreEl) {
                score += 1;
                if(score > 100) score = 0;
                scoreEl.innerText = score;
            }
        });

    </script>
</body>
</html>


